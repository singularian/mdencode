package main

// decoder4
// decoder4 is an example of a prototype parallel modulus scan on a random generated byte block
//
// decoder4 creates the byte block randomly with n-bytes and creates an n-bit modular floor
// decoder4 will then run a parallel modulus scan to find the original n-byte block with a matching signature
// decoder4 uses goroutines to run the scans in sequence
//
// copyright (C) Scott Ross 2019
// https://github.com/singularian/mdencode/blob/master/LICENSE

import ( 
	"crypto/rand"
	"fmt"
	"strconv"
	"os"
	// "log"
	"time"
	"github.com/singularian/mdencode/code/decode/modScan"
)

// generates a random n byte array and then hashes it
// it then runs it through the modulus scan
func main() {

	mddecode()
	os.Exit(0)
}

// mdecode file
func mddecode() int {

	var argsNumber int = len(os.Args)

        // test a random byte block
        // arguments:
        //   blocksize bytes 
        //   modsize bits 
        //   thread size of goroutines
        if argsNumber == 4 {
                var c chan string = make(chan string)

                blocksize  := os.Args[1]
                modsize    := os.Args[2]
                threadsize := os.Args[3]
                blocksizeint, _ := strconv.Atoi(blocksize)
		var blockSizeInt int64
		var modSizeInt int64
		var threadCount int64
		var thread int64 
		blockSizeInt, _ = strconv.ParseInt(blocksize, 10, 64) 
		modSizeInt  , _ = strconv.ParseInt(modsize, 10, 64) 
		threadCount,  _ = strconv.ParseInt(threadsize, 10, 64) 

		// create a random n byte size byte block
		bytes := make([]byte, blocksizeint)
                _, _ = rand.Read(bytes)
		// test failure with this byteblock there is a bug with the modular exponent
		// 8 bytes 40 bit mod
		/// bytes := []byte{ 0, 10, 22, 38, 240, 171, 146, 123 }
		// _, _ = rand.Read(bytes)

		// set the timestamp
        	now := time.Now()
		var time = fmt.Sprintf("%d%d%d%d%d", now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())
		// set up the thread list of go routine objects
		mdp:=[]*modScan.DecodeData{}
                for thread = 0; thread<threadCount; thread++ {
			md := modScan.Init(blockSizeInt, modSizeInt, thread, threadCount, bytes, time)
			mdp=append(mdp,md)
		}

		// kick off the thread list go routines
		for thread = 0; thread < threadCount; thread++ {
		  	go mdp[thread].ModulusScanRandom(blocksizeint, modsize, thread, 10, c)

		}

		// wait for the first channel result
		for result := range c {
			fmt.Println("result ", result)
		} 
        // print program usage
        } else {
	   fmt.Println("Usage ", os.Args[0], " [BLOCKSIZE BYTES] [MODSIZE BITS] [THREADSIZE GOROUTINES]")
	   fmt.Println("Usage ", os.Args[0], " 8 32 10")
        }


	return 0

}

